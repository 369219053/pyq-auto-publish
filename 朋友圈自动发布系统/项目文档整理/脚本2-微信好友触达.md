# 脚本2: 微信好友触达

[← 返回README](./README.md)

---

## 🎯 功能概述

批量发送消息给所有微信好友,支持**三种消息类型**:文字消息、视频号卡片、链接卡片。支持多账号轮询、智能间隔、时间控制、消息个性化等功能。适用于产品推广、活动通知等场景。

---

## 📱 三种消息类型

### 1️⃣ 文字消息
- **功能**: 发送纯文本消息给好友
- **特性**: 支持`{昵称}`变量个性化
- **示例**: "你好{昵称},这是一条测试消息"
- **适用场景**: 日常问候、活动通知、产品推广

### 2️⃣ 视频号消息
- **功能**: 发送视频号卡片给好友
- **素材来源**: 从堆雪球"视频号素材"库同步
- **数据库表**: `duixueqiu_video_materials`
- **特性**:
  - 自动同步堆雪球素材库(Puppeteer爬取)
  - 可视化选择素材(缩略图+标题)
  - 支持附加文案,可使用`{昵称}`变量
- **适用场景**: 视频号推广、内容分享

### 3️⃣ 链接消息
- **功能**: 发送公众号文章链接卡片给好友
- **素材来源**: 从堆雪球"链接素材"库同步
- **数据库表**: `duixueqiu_link_materials`
- **特性**:
  - 自动同步堆雪球素材库(Puppeteer爬取)
  - 可视化选择素材(缩略图+标题+公众号名称)
  - 支持附加文案,可使用`{昵称}`变量
- **适用场景**: 公众号文章推广、内容分享

---

## 🏗️ 技术架构

```
登录堆雪球系统
    ↓
获取所有微信号列表
    ↓
点击"全部好友"获取好友列表
    ↓
【可选】同步素材库(视频号/链接)
    ↓
轮询发送: 微信1→好友1, 微信2→好友1, 微信3→好友1...
    ↓
智能间隔 + 时间控制(8:00-22:00)
    ↓
实时进度推送(WebSocket)
```

---

## 📁 核心代码文件

### 后端

- **`pyq-backend/src/automation/wechat-reach.service.ts`**
  - `startWechatReachTask()` - 主流程函数
  - `loginDuixueqiu()` - 登录堆雪球
  - `getWechatAccounts()` - 获取微信号列表
  - `getFriendsList()` - 获取好友列表
  - `sendMessageToFriend()` - 发送文字消息
  - `sendVideoToFriend()` - 发送视频号卡片
  - `sendLinkToFriend()` - 发送链接卡片
  - `isWithinSendingHours()` - 时间控制
  - `calculateInterval()` - 间隔计算

- **`pyq-backend/src/automation/video-material.service.ts`** (797行)
  - `syncVideoMaterials()` - 同步视频号素材库
  - `loginDuixueqiu()` - 登录堆雪球
  - `openMaterialLibrary()` - 打开素材库
  - `selectMaterialType()` - 选择"视频号素材"
  - `extractMaterialsFromPage()` - 提取素材数据
  - `saveMaterialsToDatabase()` - 保存到数据库(去重)

- **`pyq-backend/src/automation/link-material.service.ts`** (797行)
  - `syncLinkMaterials()` - 同步链接素材库
  - 其他函数与`video-material.service.ts`相同
  - 区别: 选择"链接素材"类型,提取不同字段

- **`pyq-backend/src/automation/automation.controller.ts`**
  - `POST /api/automation/script2/wechat-reach` - 开始任务
  - `POST /api/automation/script2/pause` - 暂停任务
  - `POST /api/automation/script2/resume` - 恢复任务
  - `POST /api/automation/script2/stop` - 停止任务
  - `POST /api/automation/script2/status` - 查询状态
  - `POST /api/automation/script2/sync-video-materials` - 同步视频号素材
  - `GET /api/automation/script2/video-materials` - 获取视频号素材列表
  - `POST /api/automation/script2/sync-link-materials` - 同步链接素材
  - `GET /api/automation/script2/link-materials` - 获取链接素材列表

- **`pyq-backend/src/automation/automation.gateway.ts`**
  - `emitScript2Log()` - 发送日志
  - `emitProgress()` - 发送进度
  - `emitScript2Complete()` - 发送完成通知

### 前端

- **`pyq-frontend-vben/apps/web-antd/src/views/scripts/script2.vue`**
  - 用户界面和WebSocket连接
  - 三种消息类型切换(文字/视频号/链接)
  - 素材库同步和选择界面
  - 任务控制(开始/暂停/恢复/停止)

---

## 🔌 API接口

### 1. 开始任务

```typescript
POST /api/automation/script2/wechat-reach
Content-Type: application/json

// 文字消息
{
  "userId": "用户UUID",
  "messageType": "text",
  "message": "你好{昵称},这是一条测试消息",
  "targetDays": 7,
  "taskId": "task_123456"
}

// 视频号消息
{
  "userId": "用户UUID",
  "messageType": "video",
  "materialId": 123,         // 视频号素材ID
  "additionalText": "推荐给你{昵称}",  // 可选附加文案
  "targetDays": 7,
  "taskId": "task_123456"
}

// 链接消息
{
  "userId": "用户UUID",
  "messageType": "link",
  "materialId": 456,         // 链接素材ID
  "additionalText": "分享给你{昵称}",  // 可选附加文案
  "targetDays": 7,
  "taskId": "task_123456"
}

// 返回
{
  "success": true,
  "message": "任务已启动"
}
```

### 2. 同步素材库

```typescript
// 同步视频号素材
POST /api/automation/script2/sync-video-materials
Content-Type: application/json

{
  "userId": "用户UUID"
}

// 返回
{
  "success": true,
  "message": "同步成功",
  "count": 39  // 同步的素材数量
}

// 同步链接素材
POST /api/automation/script2/sync-link-materials
Content-Type: application/json

{
  "userId": "用户UUID"
}

// 返回
{
  "success": true,
  "message": "同步成功",
  "count": 25
}
```

### 3. 获取素材列表

```typescript
// 获取视频号素材
GET /api/automation/script2/video-materials?userId={userId}

// 返回
{
  "success": true,
  "data": [
    {
      "id": 1,
      "userId": "uuid",
      "authorName": "作者名称",
      "contentDesc": "视频描述",
      "thumbnailUrl": "缩略图URL",
      "materialIndex": 0,
      "pageNumber": 1,
      "syncTime": "2025-11-11T10:00:00.000Z"
    }
  ]
}

// 获取链接素材
GET /api/automation/script2/link-materials?userId={userId}

// 返回
{
  "success": true,
  "data": [
    {
      "id": 1,
      "userId": "uuid",
      "title": "文章标题",
      "accountName": "公众号名称",
      "thumbnailUrl": "缩略图URL",
      "linkUrl": "文章链接",
      "materialIndex": 0,
      "pageNumber": 1,
      "syncTime": "2025-11-11T10:00:00.000Z"
    }
  ]
}
```

### 4. 暂停/恢复/停止任务

```typescript
POST /api/automation/script2/pause
POST /api/automation/script2/resume
POST /api/automation/script2/stop
Content-Type: application/json

{
  "taskId": "task_123456"
}
```

### 5. WebSocket实时推送

```typescript
// 连接
ws://localhost:3000/automation/ws/{taskId}

// 接收日志
{
  "event": "script2Log",
  "data": {
    "taskId": "task_123456",
    "log": "正在发送消息给好友: 张三",
    "timestamp": "2025-11-07T10:00:00.000Z"
  }
}

// 接收进度
{
  "event": "script2Progress",
  "data": {
    "taskId": "task_123456",
    "sentCount": 10,
    "totalFriends": 100,
    "currentFriend": "张三",
    "currentWechat": "微信1",
    "progress": 10
  }
}

// 接收完成通知
{
  "event": "script2Complete",
  "data": {
    "taskId": "task_123456",
    "success": true,
    "message": "任务完成"
  }
}
```

---

## �️ 数据库表结构

### 1. duixueqiu_video_materials (视频号素材表)

```sql
CREATE TABLE duixueqiu_video_materials (
  id SERIAL PRIMARY KEY,
  user_id UUID NOT NULL,              -- 用户ID (关联users表)
  author_name VARCHAR(200),            -- 视频号作者名称
  content_desc TEXT,                   -- 视频描述
  thumbnail_url TEXT,                  -- 缩略图URL
  material_index INT,                  -- 素材在列表中的索引位置
  page_number INT DEFAULT 1,           -- 素材所在页码
  sync_time TIMESTAMP DEFAULT NOW(),   -- 最后同步时间
  create_time TIMESTAMP DEFAULT NOW(), -- 创建时间
  UNIQUE(user_id, thumbnail_url)       -- 去重约束
);

-- 索引
CREATE INDEX idx_duixueqiu_video_materials_user_id ON duixueqiu_video_materials(user_id);
CREATE INDEX idx_duixueqiu_video_materials_sync_time ON duixueqiu_video_materials(sync_time);

-- 外键约束
ALTER TABLE duixueqiu_video_materials
  ADD CONSTRAINT fk_duixueqiu_video_materials_user_id
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
```

**字段说明:**
- `user_id`: 用户UUID,关联到`users`表
- `author_name`: 视频号作者名称
- `content_desc`: 视频内容描述
- `thumbnail_url`: 视频缩略图URL,用于去重
- `material_index`: 素材在堆雪球素材库中的索引位置(用于定位点击)
- `page_number`: 素材所在页码(用于翻页)
- `sync_time`: 最后同步时间,用于判断是否需要重新同步

### 2. duixueqiu_link_materials (链接素材表)

```sql
CREATE TABLE duixueqiu_link_materials (
  id SERIAL PRIMARY KEY,
  user_id UUID NOT NULL,              -- 用户ID (关联users表)
  title VARCHAR(500) NOT NULL,         -- 文章标题
  account_name TEXT,                   -- 公众号名称
  thumbnail_url TEXT,                  -- 缩略图URL
  link_url TEXT,                       -- 文章链接URL
  material_index INT,                  -- 素材在列表中的索引位置
  page_number INT DEFAULT 1,           -- 素材所在页码
  sync_time TIMESTAMP DEFAULT NOW(),   -- 最后同步时间
  create_time TIMESTAMP DEFAULT NOW(), -- 创建时间
  UNIQUE(user_id, thumbnail_url)       -- 去重约束
);

-- 索引
CREATE INDEX idx_duixueqiu_link_materials_user_id ON duixueqiu_link_materials(user_id);
CREATE INDEX idx_duixueqiu_link_materials_title ON duixueqiu_link_materials(title);
CREATE INDEX idx_duixueqiu_link_materials_sync_time ON duixueqiu_link_materials(sync_time);

-- 外键约束
ALTER TABLE duixueqiu_link_materials
  ADD CONSTRAINT fk_duixueqiu_link_materials_user_id
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;
```

**字段说明:**
- `user_id`: 用户UUID,关联到`users`表
- `title`: 文章标题
- `account_name`: 公众号名称(TEXT类型,无长度限制)
- `thumbnail_url`: 文章缩略图URL,用于去重
- `link_url`: 文章链接URL
- `material_index`: 素材在堆雪球素材库中的索引位置
- `page_number`: 素材所在页码
- `sync_time`: 最后同步时间

**数据库设计要点:**
1. **UUID类型**: `user_id`使用UUID类型,与`users`表保持一致
2. **TEXT类型**: `account_name`使用TEXT类型,避免公众号名称过长导致截断
3. **去重约束**: 使用`UNIQUE(user_id, thumbnail_url)`避免重复同步
4. **级联删除**: 用户删除时自动删除关联的素材数据
5. **索引优化**: 在常用查询字段上创建索引,提高查询性能

---

## �📊 数据流程

### 步骤1: 登录堆雪球 (loginDuixueqiu)

- 访问 `https://dxqscrm.duixueqiu.cn/`
- 输入账号密码: `lifangde001 / Lfd666888#`
- 等待登录成功

### 步骤2: 获取微信号列表 (getWechatAccounts)

- 点击"微信号管理"
- 提取所有微信号ID和名称
- 返回数组: `[{id, name}]`

### 步骤3: 获取好友列表 (getFriendsList)

- 点击"全部好友"(不是"未分组")
- 点击"好友列表"标签
- 滚动加载所有好友
- 提取好友ID和昵称

### 步骤4: 轮询发送 (sendMessageToFriend)

- 切换微信号: `switchWechatAccount()`
- 点击好友
- 输入消息(替换{昵称}变量)
- 点击发送
- 等待间隔时间

### 步骤5: 时间控制 (isWithinSendingHours)

- 检查当前时间是否在8:00-22:00
- 如果不在,暂停并等待次日8:00
- 保存进度,次日自动恢复

---

## 🔑 关键技术点

### 1. 视频号素材选择的Puppeteer实现

视频号素材选择是整个功能中最复杂的部分,涉及多层对话框和精确的元素定位。

#### 核心挑战

1. **多层对话框区分**: 堆雪球系统有主对话框和微小号选择对话框,需要精确区分
2. **按钮文本差异**: 主对话框的"确定"按钮和微小号对话框的"确 定"按钮(中间有空格)
3. **Element UI组件**: 需要理解Element UI的DOM结构和类名规则

#### 完整流程(11个步骤)

```typescript
// 步骤1: 打开素材库
await page.click('a[href="#/material/library"]');
await page.waitForSelector('.material-library-container', { timeout: 10000 });

// 步骤2: 选择"视频号素材"类型
await page.evaluate(() => {
  const buttons = document.querySelectorAll('button');
  for (const button of buttons) {
    if (button.textContent?.includes('视频号素材')) {
      button.click();
      return;
    }
  }
});

// 步骤3-11: 选择素材并发送
// (详见下方"素材选择核心代码")
```

#### 素材选择核心代码

**关键技术: 鼠标模拟点击 + Element UI选择器优先级**

```typescript
// ✅ 正确方法: 使用鼠标模拟点击
async selectVideoMaterial(page, materialIndex) {
  // 1. 获取素材元素的坐标
  const coordinates = await page.evaluate((index) => {
    const items = document.querySelectorAll('.material-item');
    const item = items[index];
    if (!item) return null;

    const rect = item.getBoundingClientRect();
    return {
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2
    };
  }, materialIndex);

  // 2. 使用鼠标移动并点击
  await page.mouse.move(coordinates.x, coordinates.y);
  await page.mouse.click(coordinates.x, coordinates.y);

  // 3. 等待对话框出现
  await page.waitForSelector('.el-dialog__wrapper', { visible: true });

  // 4. 点击"发送给好友"按钮 (优先选择.el-button--success)
  await page.evaluate(() => {
    // 优先查找绿色按钮(Element UI的success类型)
    const successButton = document.querySelector('button.el-button--success');
    if (successButton && successButton.textContent?.includes('发送给好友')) {
      successButton.click();
      return;
    }

    // 备选: 查找所有按钮
    const buttons = document.querySelectorAll('button');
    for (const button of buttons) {
      if (button.textContent?.includes('发送给好友')) {
        button.click();
        return;
      }
    }
  });

  // 5. 等待微小号选择对话框出现
  await page.waitForFunction(() => {
    const dialogs = document.querySelectorAll('.el-dialog__wrapper');
    for (const dialog of dialogs) {
      const title = dialog.querySelector('.el-dialog__title');
      if (title?.textContent?.includes('选择微小号')) {
        return true;
      }
    }
    return false;
  }, { timeout: 5000 });

  // 6. 在微小号对话框中点击"确 定"按钮(注意中间有空格)
  await page.evaluate(() => {
    // 查找包含"选择微小号"标题的对话框
    const dialogs = document.querySelectorAll('.el-dialog__wrapper');
    for (const dialog of dialogs) {
      const title = dialog.querySelector('.el-dialog__title');
      if (title?.textContent?.includes('选择微小号')) {
        // 在footer中查找"确 定"按钮(中间有空格)
        const footer = dialog.querySelector('.el-dialog__footer');
        if (footer) {
          const buttons = footer.querySelectorAll('button');
          for (const button of buttons) {
            const text = button.textContent?.trim();
            // 关键: 匹配"确 定"(中间有空格),而不是"确定"
            if (text === '确 定' || text?.includes('确') && text?.includes('定')) {
              button.click();
              return;
            }
          }
        }
      }
    }
  });
}
```

#### 关键技术要点

**1. 鼠标模拟点击 vs 直接element.click()**

```typescript
// ❌ 错误方法: 直接点击可能失败
await page.evaluate((index) => {
  const items = document.querySelectorAll('.material-item');
  items[index].click(); // 可能被其他元素遮挡
}, materialIndex);

// ✅ 正确方法: 使用鼠标模拟
const rect = await page.evaluate((index) => {
  const item = document.querySelectorAll('.material-item')[index];
  const rect = item.getBoundingClientRect();
  return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
}, materialIndex);

await page.mouse.move(rect.x, rect.y);
await page.mouse.click(rect.x, rect.y);
```

**2. Element UI按钮选择器优先级**

```typescript
// 优先级1: 使用Element UI的类型类名
const successButton = document.querySelector('button.el-button--success');

// 优先级2: 使用文本内容匹配
const buttons = document.querySelectorAll('button');
for (const button of buttons) {
  if (button.textContent?.includes('发送给好友')) {
    button.click();
  }
}
```

**3. 多层对话框精确定位**

```typescript
// 通过对话框标题区分不同对话框
const dialogs = document.querySelectorAll('.el-dialog__wrapper');
for (const dialog of dialogs) {
  const title = dialog.querySelector('.el-dialog__title');

  // 微小号选择对话框
  if (title?.textContent?.includes('选择微小号')) {
    const footer = dialog.querySelector('.el-dialog__footer');
    // 在footer中查找按钮,避免误点主对话框的按钮
  }
}
```

**4. 按钮文本精确匹配**

```typescript
// 主对话框的"确定"按钮: 无空格
const mainDialogButton = '确定';

// 微小号对话框的"确 定"按钮: 中间有空格
const miniAccountDialogButton = '确 定';

// 匹配时需要考虑空格差异
const text = button.textContent?.trim();
if (text === '确 定' || (text?.includes('确') && text?.includes('定'))) {
  button.click();
}
```

#### 常见问题和解决方案

**问题1: 测试脚本与生产代码逻辑不一致**

- **现象**: 本地测试脚本能工作,但生产代码失败
- **原因**: 测试脚本使用了不同的选择器或点击方式
- **解决**: 确保测试脚本和生产代码的所有11个步骤完全一致

**问题2: PM2工作目录错误导致环境变量读取失败**

- **现象**: 服务启动报错 `supabaseUrl is required`
- **原因**: PM2从`/root`启动,无法读取`/www/wwwroot/pyq-backend/.env`
- **解决**: 从正确的工作目录启动PM2
  ```bash
  cd /www/wwwroot/pyq-backend && pm2 start dist/main.js --name pyq-backend
  ```

**问题3: Vue Router keep-alive导致页面空白**

- **现象**: 切换到其他页面后,再回到Script2页面显示空白
- **原因**: `onActivated`钩子中的异步操作没有正确处理
- **解决**: 添加`async/await`和`try-catch`错误处理
  ```typescript
  onActivated(async () => {
    try {
      await loadMaterialStats();
      await loadMaterials();
      await loadFriends();
      if (!socket.value || !socket.value.connected) {
        initWebSocket();
      }
    } catch (error) {
      console.error('❌ 页面激活时加载数据失败:', error);
    }
  });
  ```

### 2. 多账号轮询策略

```typescript
// 轮询顺序: 微信1→好友1, 微信2→好友1, 微信3→好友1...
for (let i = 0; i < friends.length; i++) {
  const wechatIndex = i % wechatAccounts.length;
  const wechat = wechatAccounts[wechatIndex];
  await switchWechatAccount(wechat.id);
  await sendMessageToFriend(friends[i].name, message);
}
```

### 3. 素材库同步的Puppeteer实现

素材库同步功能自动从堆雪球系统爬取视频号和链接素材,保存到数据库供前端选择。

#### 同步流程

```typescript
async syncVideoMaterials(userId: string) {
  // 1. 登录堆雪球
  await this.loginDuixueqiu(page);

  // 2. 打开素材库
  await page.click('a[href="#/material/library"]');
  await page.waitForSelector('.material-library-container');

  // 3. 选择"视频号素材"类型
  await page.evaluate(() => {
    const buttons = document.querySelectorAll('button');
    for (const button of buttons) {
      if (button.textContent?.includes('视频号素材')) {
        button.click();
        return;
      }
    }
  });

  // 4. 等待素材加载
  await page.waitForSelector('.material-item', { timeout: 10000 });

  // 5. 提取素材数据
  const materials = await page.evaluate(() => {
    const items = document.querySelectorAll('.material-item');
    return Array.from(items).map((item, index) => ({
      authorName: item.querySelector('.author-name')?.textContent?.trim(),
      contentDesc: item.querySelector('.content-desc')?.textContent?.trim(),
      thumbnailUrl: item.querySelector('img')?.src,
      materialIndex: index,
      pageNumber: 1
    }));
  });

  // 6. 保存到数据库(去重)
  await this.saveMaterialsToDatabase(userId, materials);
}
```

#### 去重策略

使用数据库UNIQUE约束自动去重:

```sql
UNIQUE(user_id, thumbnail_url)
```

```typescript
// 插入时使用ON CONFLICT DO NOTHING
await this.supabase
  .from('duixueqiu_video_materials')
  .insert(materials)
  .onConflict(['user_id', 'thumbnail_url'])
  .ignore();
```

### 4. 智能间隔计算

```typescript
calculateInterval(totalFriends, wechatCount, targetDays) {
  const totalSeconds = targetDays * 24 * 60 * 60;
  const baseInterval = totalSeconds / totalFriends;
  const actualInterval = baseInterval * wechatCount;
  return {
    baseInterval,      // 基础间隔(秒)
    actualInterval,    // 实际间隔(秒)
    dailySend: Math.ceil(totalFriends / targetDays)  // 每天发送数
  };
}
```

### 5. 时间控制机制

```typescript
async waitForNextSendingTime() {
  const now = new Date();
  const hour = now.getHours();

  if (hour >= 22 || hour < 8) {
    // 计算到次日8:00的等待时间
    const tomorrow8am = new Date(now);
    tomorrow8am.setDate(tomorrow8am.getDate() + (hour >= 22 ? 1 : 0));
    tomorrow8am.setHours(8, 0, 0, 0);

    const waitMs = tomorrow8am.getTime() - now.getTime();
    await new Promise(resolve => setTimeout(resolve, waitMs));
  }
}
```

### 6. 消息个性化

```typescript
const personalizedMessage = message.replace(/{昵称}/g, friendName);
```

### 7. 任务控制

- **暂停**: 设置`isPaused = true`,当前消息发送完后停止
- **恢复**: 设置`isPaused = false`,从上次位置继续
- **停止**: 设置`isStopped = true`,立即终止任务

### 8. Vue Router Keep-Alive处理

Script2页面使用Vue Router的keep-alive缓存,需要正确处理`onActivated`生命周期钩子。

#### 问题场景

- 用户从Script2切换到其他页面,再切换回来
- keep-alive缓存的组件只触发`onActivated`,不触发`onMounted`
- 如果`onActivated`中的异步操作没有正确处理,页面会显示空白

#### 解决方案

```typescript
// ✅ 正确的onActivated实现
onActivated(async () => {
  console.log('🔄 Script2页面已激活 (onActivated)');

  try {
    // 重新初始化WebSocket连接
    if (!socket.value || !socket.value.connected) {
      initWebSocket();
    }

    // 重新加载所有数据
    await loadMaterialStats();
    await loadMaterials();
    await loadLinkStats();
    await loadLinks();
    await loadFriends();

    addLog('🔄 页面数据已刷新');
  } catch (error) {
    console.error('❌ 页面激活时加载数据失败:', error);
    // 即使出错也不会导致页面崩溃
  }
});
```

#### 关键要点

1. **必须使用async**: `onActivated(async () => { ... })`
2. **必须await异步操作**: `await loadMaterials()`
3. **必须添加错误处理**: `try-catch`包裹所有异步操作
4. **WebSocket重连**: 检查连接状态并重新初始化
5. **数据刷新**: 重新加载所有必要的数据

---

## ⚠️ 已知问题

### 1. 堆雪球账号硬编码

- 当前账号密码写死在代码中
- 需要改为从数据库读取
- 支持多个堆雪球账号配置

### 2. 好友列表HTML结构未验证

- 代码基于假设的HTML结构编写
- 需要实际测试验证
- 可能需要调整选择器

### 3. 发送失败无重试

- 当前发送失败直接跳过
- 需要添加重试机制
- 记录失败原因

### 4. 无发送成功率统计

- 无法知道实际发送成功多少条
- 需要添加统计功能
- 生成发送报告

---

## 📖 使用指南

### 视频号消息发送流程

#### 第一步: 在堆雪球中收藏视频号

1. 在微信中找到要发送的视频号
2. 发送给工作微信
3. 在堆雪球客户端中右键点击该消息
4. 选择"收藏到素材库"
5. 选择"公共素材分组"
6. 保存

#### 第二步: 同步素材库

1. 打开脚本2页面
2. 选择"视频号消息"
3. 点击"同步素材库"按钮
4. 等待同步完成(约10-30秒)

#### 第三步: 选择素材并发送

1. 在素材列表中选择要发送的视频号
2. (可选)输入附加文案,支持`{昵称}`变量
3. 选择目标完成时间(如7天)
4. 点击"开始发送"
5. 查看实时进度和日志

### 链接消息发送流程

与视频号消息类似,只需在第二步选择"链接消息"类型即可。

---

## 🔍 技术要点详解

### 🎯 2025-11-10 重大突破

#### 1. 分页检测逻辑完善

**问题**: 最初只能获取第1页素材(20个),无法获取所有页

**解决方案**:
```typescript
// 检测下一页按钮
private async hasNextPage(page: puppeteer.Page): Promise<boolean> {
  const hasNext = await page.evaluate(() => {
    // 查找所有包含右箭头图标的按钮
    const rightArrowButtons = Array.from(document.querySelectorAll('button')).filter(btn => {
      const icon = btn.querySelector('.el-icon-arrow-right');
      return icon !== null;
    });

    // 检查是否有未禁用的下一页按钮
    for (const button of rightArrowButtons) {
      const isDisabled = button.classList.contains('is-disabled') || button.disabled;
      if (!isDisabled) {
        return true;
      }
    }
    return false;
  });
  return hasNext;
}
```

**关键点**:
- ✅ 使用`.el-icon-arrow-right`图标定位下一页按钮
- ✅ 检查`is-disabled`类和`disabled`属性
- ✅ 成功实现多页素材获取(从20个→39个)

#### 2. 数据去重优化

**问题**: 使用`(user_id, author_name, content_desc)`组合去重导致素材丢失

**原因**: 多个视频可能有相同的作者和描述

**解决方案**:
```typescript
// 使用thumbnail_url作为唯一标识
const uniqueMaterials = new Map<string, any>();
materialsToInsert.forEach(material => {
  const key = `${material.user_id}_${material.thumbnail_url}`;
  uniqueMaterials.set(key, material);
});
```

**数据库约束调整**:
```sql
-- 删除旧约束
ALTER TABLE duixueqiu_video_materials
DROP CONSTRAINT duixueqiu_video_materials_user_id_author_name_content_desc_key;

-- 使用新约束
UNIQUE(user_id, thumbnail_url)
```

**效果**: 成功同步所有39个素材,无重复无遗漏

#### 3. 前端UI优化

**素材选择弹窗化**:
```vue
<!-- 使用Vben Admin的Modal组件 -->
<MaterialModal
  class="w-[90vw] max-w-[1400px] h-[85vh]"
  title="选择视频号素材"
  :footer="false"
>
  <!-- 素材网格: 一行6个 -->
  <div class="grid grid-cols-6 gap-3 max-h-[calc(85vh-120px)] overflow-y-auto">
    <!-- 素材卡片 -->
  </div>
</MaterialModal>
```

**优化点**:
- ✅ 弹窗宽度: 1400px (原1200px)
- ✅ 弹窗高度: 85vh (原600px固定高度)
- ✅ 素材网格: 一行6个 (原4个)
- ✅ 消息类型选择区域高度压缩

---

## 🔧 Puppeteer选择器参考

**重要**: 以下选择器需要根据堆雪球实际HTML结构调整

### 素材库相关选择器

```typescript
// 素材按钮
await page.click('[title="素材"]');

// 视频号素材菜单
await page.click('div:has-text("视频号素材")');

// 链接素材菜单
await page.click('div:has-text("链接素材")');

// 公共素材分组
await page.click('div:has-text("公共素材分组")');

// 素材项
const materialItems = await page.$$('.item-resource');

// 分页按钮
const nextButton = await page.$('button .el-icon-arrow-right');
```

### 发送相关选择器

```typescript
// 好友选择
await page.click(`[title="${friendName}"]`);

// 聊天框输入
await page.type('#editArea', message);

// 发送按钮
await page.click('.send-btn');
```

---

## 🛠️ 调试建议

1. **使用headless: false** - 查看浏览器实际操作过程
2. **添加截图** - 在关键步骤添加`await page.screenshot()`记录状态
3. **使用waitForSelector** - 等待元素加载完成,避免元素未找到错误
4. **避免硬编码延迟** - 使用智能等待(`waitForSelector`, `waitForNavigation`)替代`setTimeout`
5. **使用page.evaluate** - 在浏览器上下文中执行复杂逻辑,提高性能

---

## ⚠️ 注意事项

### 1. 素材库同步

- ✅ 首次使用需要先同步素材库
- ✅ 建议定期同步(如每天一次)
- ✅ 同步时间取决于素材数量(约10-30秒)
- ⚠️ 同步过程中不要关闭浏览器

### 2. 发送限制

- ✅ 遵循微信发送频率限制
- ✅ 建议设置合理的目标天数(7-14天)
- ✅ 避免短时间大量发送(可能被微信限制)
- ⚠️ 发送时间控制在8:00-22:00

### 3. 选择器维护

- ✅ 堆雪球界面更新可能导致选择器失效
- ✅ 需要定期检查和更新选择器
- ✅ 建议使用更稳定的选择器(如data-*属性)
- ⚠️ 选择器失效时查看浏览器控制台错误信息

---

## 📋 待优化项

- [ ] 堆雪球账号配置化
- [ ] 好友列表HTML结构验证
- [ ] 发送失败重试机制
- [ ] 发送成功率统计
- [ ] 支持分组发送
- [ ] 支持黑名单过滤
- [ ] 添加发送报告导出

---

## 🔗 相关文档

- [脚本1: 输入链接自动发布](./脚本1-输入链接自动发布.md)
- [脚本3: 定时监控自动发布](./脚本3-定时监控自动发布.md)
- [脚本4: 跟圈自动化](./脚本4-跟圈自动化.md)
- [部署指南](./部署指南.md)
- [常见问题](./常见问题.md)

---

## 🐛 重要Bug修复记录

### 好友同步功能 - 微信号切换失败问题 (V5.5.2)

#### 问题描述

**现象:**
- 点击"1号机"进行好友同步
- 页面显示"1号机"被选中(CSS的`.selected`类正确应用)
- 但实际加载的是"10号机"的好友数据(9948个好友而不是6396个)
- 导致同步错误的微信号好友数据

**影响范围:**
- 所有微信号的好友同步功能
- 数据不一致,用户体验混乱

#### 根本原因

堆雪球平台使用Vue.js框架,微信号列表的点击事件通过Vue的`@click`事件监听器处理。

**Puppeteer的三种点击方式对比:**

| 点击方式 | 代码 | 是否触发Vue事件 | 结果 |
|---------|------|----------------|------|
| Puppeteer原生点击 | `elementHandle.click()` | ❌ 否 | 只触发DOM事件,不触发Vue |
| JavaScript点击 | `element.click()` | ❌ 否 | 只改变CSS样式,不更新Vue数据 |
| 模拟鼠标事件 | `dispatchEvent(MouseEvent)` | ✅ 是 | 正确触发Vue事件监听器 |

**问题核心:** JavaScript的`click()`方法只触发元素的`onclick`属性,无法触发Vue的`@click`事件监听器,导致CSS样式改变但Vue数据状态未更新。

#### 解决方案

**1. 使用dispatchEvent模拟真实鼠标点击**

```typescript
// ❌ 错误的方式 - 不触发Vue事件
const clickResult = await page.evaluate((name) => {
  const items = document.querySelectorAll('.wechat-account-list > .item');
  for (const item of items) {
    const nameDiv = item.querySelector('.name');
    if (nameDiv && nameDiv.textContent?.trim() === name) {
      (item as HTMLElement).click(); // 只改变CSS,不触发Vue
      return { success: true };
    }
  }
  return { success: false };
}, accountName);

// ✅ 正确的方式 - 触发Vue事件
const clickResult = await page.evaluate((name) => {
  const items = document.querySelectorAll('.wechat-account-list > .item');
  for (const item of items) {
    const nameDiv = item.querySelector('.name');
    if (nameDiv && nameDiv.textContent?.trim() === name) {
      // 模拟真实的鼠标点击事件
      const clickEvent = new MouseEvent('click', {
        view: window,
        bubbles: true,    // 事件冒泡
        cancelable: true  // 可取消
      });
      item.dispatchEvent(clickEvent); // 触发Vue事件监听器
      return { success: true, title: item.getAttribute('title') || '' };
    }
  }
  return { success: false, title: '' };
}, accountName);
```

**2. 增加双重验证逻辑**

不仅检查CSS样式,还要验证Vue的数据状态是否真正改变:

```typescript
// 同时获取好友数和当前选中的微信号
const result = await page.evaluate((targetName) => {
  // 获取未分组好友数
  let friendCount = 0;
  const allSpans = document.querySelectorAll('span');
  for (const span of allSpans) {
    const text = span.textContent?.trim() || '';
    const match = text.match(/^未分组[（(](\d+)个[）)]$/);
    if (match) {
      friendCount = parseInt(match[1], 10);
      break;
    }
  }

  // 获取当前选中的微信号
  let selectedAccount = '';
  const items = document.querySelectorAll('.wechat-account-list > .item');
  for (const item of items) {
    if (item.classList.contains('selected')) {
      const nameDiv = item.querySelector('.name');
      selectedAccount = nameDiv?.textContent?.trim() || '';
      break;
    }
  }

  return { friendCount, selectedAccount };
}, accountName);

// 验证:好友数>0 且 选中的微信号正确
if (result.friendCount > 0 && result.selectedAccount === accountName) {
  this.logger.log(`✅ 验证通过! 好友数: ${result.friendCount}, 选中: ${result.selectedAccount}`);
  clickSuccess = true;
} else if (result.friendCount > 0 && result.selectedAccount !== accountName) {
  this.logger.warn(`⚠️ 微信号不匹配! 当前: ${result.selectedAccount}, 期望: ${accountName}`);
  // 触发重试
}
```

**3. 自动重试机制**

```typescript
let retryCount = 0;
const maxRetries = 5;
let clickSuccess = false;

while (!clickSuccess && retryCount < maxRetries) {
  if (retryCount > 0) {
    this.logger.warn(`🔄 第 ${retryCount + 1} 次尝试点击微信号: ${accountName}`);
  }

  // 执行点击和验证...

  if (!clickSuccess) {
    retryCount++;
    await new Promise(resolve => setTimeout(resolve, 2000)); // 等待2秒后重试
  }
}
```

**4. 滚动加载参数优化**

```typescript
const maxScrollAttempts = 5000; // 从2000增加到5000次
const stableCount = 100;        // 从10增加到100(连续50秒不变才停止)
```

**计算依据:**
- 每次滚动加载约2-5个好友
- 6396个好友需要约3200次滚动
- 设置5000次确保有足够余量

#### 修复效果

**修复前:**
```
✅ 已点击微信号: 1号机
✅ 好友数据已更新! 从 0 变为 9948  ❌ 错误!
🔍 当前选中的微信号: 沪港纪老板(10号机)  ❌ 错误!
```

**修复后:**
```
🔄 第 3 次尝试点击微信号: 1号机
✅ 已使用JavaScript点击微信号: 1号机
✅ 好友数据已更新! 好友数: 6396, 选中微信号: 1号机  ✅ 正确!
📊 已收集 275 个好友... (滚动次数: 50)
📊 已收集 544 个好友... (滚动次数: 100)
📊 已收集 2648 个好友... (滚动次数: 500)
```

#### 技术要点总结

1. **Vue事件触发**: 使用`dispatchEvent(new MouseEvent('click'))`而不是`element.click()`
2. **双重验证**: 不仅检查CSS样式,还要验证Vue的数据状态
3. **自动重试**: 遇到失败自动重试,提高成功率
4. **耐心等待**: Vue渲染需要时间,给足够的超时时间(90秒)
5. **滚动策略**: 虚拟滚动需要持续滚动,设置足够的次数和稳定性阈值

#### 适用场景

这个解决方案适用于所有使用Vue.js/React等框架的SPA应用的Puppeteer自动化场景,特别是需要触发框架事件监听器的情况。

---

[← 返回README](./README.md)

